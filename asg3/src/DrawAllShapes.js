var g_map=[
   // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
]

const MAZE_LAYOUT = [
   [1,1,1,1,1,1,1,1,1],
   [0,0,0,0,1,0,0,0,1],
   [1,0,1,1,1,1,1,0,1],
   [1,0,0,0,0,0,1,0,0], // Entrance from Z positive (bottom of array), path to (0,0) world
   [1,1,1,0,1,1,1,0,1],
   [1,0,0,0,1,0,0,0,1],
   [1,0,1,1,1,0,1,1,1],
   [1,0,0,0,0,0,0,0,1],
   [1,1,1,1,1,1,1,1,1]
 ];
 // Center of this 9x9 maze is MAZE_LAYOUT[4][4] - this should be the tree spot (0)
 // Let's adjust so tree is at layout[4][4]
 // MAZE_LAYOUT[4][4] = 0; // Ensure center is open for the tree
 
 const MAZE_BLOCK_SIZE = 1.0; // Each cube is 1x1x1 world units
 const MAZE_WALL_HEIGHT_CUBES = 2; // Walls are 2 cubes high
 const DIRT_TEXTURE_INDEX = 2; // Corresponds to u_Sampler2 and gl.TEXTURE2

function drawFence() {
   const fencePostColor = [0.6, 0.4, 0.2, 1.0];    // Brownish color for posts
   const fenceRailColor = [0.65, 0.45, 0.25, 1.0]; // Slightly lighter for rails
   const groundLevel = -0.25;                      // Base Y level for objects on the floor

   // Define fence dimensions and properties
   const fenceRadius = 0.7; // Half-width of the fenced area (tree's widest part is ~0.3 radius)
   const postDimensions = { w: 0.1, h: 0.5, d: 0.1 }; // Width, Height, Depth of posts
   const railDimensions = { h: 0.08, d: 0.05 };       // Height, Depth of rails (length will vary)

   // Helper function to create and render a fence component
   function createFenceComponent(color, matrix) {
       let component = new Cube();
       component.color = color;
       component.textureNum = -2;
       component.matrix = matrix;
       component.renderfast();
   }

   // --- Corner Posts ---
   const postPositions = [
       [-fenceRadius, groundLevel + postDimensions.h / 2, -fenceRadius], // Front-left
       [ fenceRadius, groundLevel + postDimensions.h / 2, -fenceRadius], // Front-right
       [-fenceRadius, groundLevel + postDimensions.h / 2,  fenceRadius], // Back-left
       [ fenceRadius, groundLevel + postDimensions.h / 2,  fenceRadius]  // Back-right
   ];

   for (let pos of postPositions) {
       let matrix = new Matrix4();
       matrix.translate(pos[0], pos[1], pos[2]);
       matrix.scale(postDimensions.w, postDimensions.h, postDimensions.d);
       matrix.translate(-0.5, -0.5, -0.5);
       createFenceComponent(fencePostColor, matrix);
   }

   // --- Rails ---
   const railYCoords = [
       groundLevel + 0.15 + railDimensions.h / 2, // Lower rail
       groundLevel + 0.35 + railDimensions.h / 2  // Upper rail
   ];
   const railLength = fenceRadius * 2; // The full length of a side of the fence

   // Front and Back Rails
   for (let z_coord of [-fenceRadius, fenceRadius]) {
       for (let y_coord of railYCoords) {
           let matrix = new Matrix4();
           matrix.translate(0, y_coord, z_coord);
           matrix.scale(railLength, railDimensions.h, railDimensions.d);
           matrix.translate(-0.5, -0.5, -0.5);
           createFenceComponent(fenceRailColor, matrix);
       }
   }

   for (let x_coord of [-fenceRadius, fenceRadius]) {
       for (let y_coord of railYCoords) {
           let matrix = new Matrix4();
           matrix.translate(x_coord, y_coord, 0);
           matrix.scale(railDimensions.d, railDimensions.h, railLength);
           matrix.translate(-0.5, -0.5, -0.5);
           createFenceComponent(fenceRailColor, matrix);
       }
   }
}

// In DrawAllShapes.js

function drawMaze() {
   const groundLevel = -0.25; // Base Y level for objects on the floor
   const mazeRows = MAZE_LAYOUT.length;
   const mazeCols = MAZE_LAYOUT[0].length;

   // Calculate offsets to center the maze around world (0,0)
   // such that MAZE_LAYOUT[mazeRows/2][mazeCols/2] corresponds to world (0,0)
   const offsetX = -( (mazeCols -1) / 2.0) * MAZE_BLOCK_SIZE;
   const offsetZ = -( (mazeRows -1) / 2.0) * MAZE_BLOCK_SIZE;

   for (let r = 0; r < mazeRows; r++) {
       for (let c = 0; c < mazeCols; c++) {
           if (MAZE_LAYOUT[r][c] === 1) { // It's a wall
               for (let h = 0; h < MAZE_WALL_HEIGHT_CUBES; h++) {
                   let wallBlock = new Cube();
                   wallBlock.textureNum = DIRT_TEXTURE_INDEX; // Use dirt texture

                   let worldX = c * MAZE_BLOCK_SIZE + offsetX;
                   let worldZ = r * MAZE_BLOCK_SIZE + offsetZ;
                   // Center Y of the current cube in the wall stack
                   let worldY = groundLevel + (h * MAZE_BLOCK_SIZE) + (MAZE_BLOCK_SIZE / 2);

                   wallBlock.matrix = new Matrix4();
                   wallBlock.matrix.translate(worldX, worldY, worldZ);
                   wallBlock.matrix.scale(MAZE_BLOCK_SIZE, MAZE_BLOCK_SIZE, MAZE_BLOCK_SIZE);
                   wallBlock.matrix.translate(-0.5, -0.5, -0.5); // Center unit cube

                   // IMPORTANT: Maze walls need to be textured.
                   // Cube.render() is designed for this (face-by-face with UVs).
                   // Cube.renderfast() is for solid colors and doesn't handle UVs.
                   wallBlock.render(); 
               }
           }
       }
   }
}

function drawAllShapes(){
   // drawFence();
   drawMaze();

   // Sky
   var sky = new Cube();
   sky.color = [.6, .9, .95, 1];
   sky.textureNum = 1;
   sky.matrix = new Matrix4();
   sky.matrix.translate(0, 15.5, 0);
   sky.matrix.scale(32, 32, 32);
   sky.matrix.translate(-0.5, -0.5, -0.5);
   sky.render();

   // Floor
   var floor = new Cube();
   floor.color = [.2, .9, .4, 1];
   floor.textureNum = 0;
   floor.matrix.translate(0, -0.25, 0);
   floor.matrix.scale(32, 0.01, 32);
   floor.matrix.translate(-.5, -15.5, -.5);

   // Adjust the thickness of the floor
   var floorThickness = 0.05;
   floor.matrix = new Matrix4();
   floor.matrix.translate(0, -0.25 - (floorThickness/2), 0);
   floor.matrix.scale(32, floorThickness, 32);
   floor.matrix.translate(-0.5, -0.5, -0.5);
   floor.render();

   // Trunk
   var trunk = new Cube();
   trunk.color = [0.5, 0.35, 0.2, 1.0];
   trunk.textureNum = -2;
   var trunkMatrix = new Matrix4();
   trunkMatrix.translate(-0.1, -0.25, -0.1);
   trunkMatrix.scale(0.2, 1.0, 0.2);
   trunk.matrix = trunkMatrix;
   trunk.renderfast();

   // Leaves
   var leaves = new Cube();
   leaves.color = [0.2, 0.6, 0.1, 1.0];
   leaves.textureNum = -2;
   var leavesMatrix = new Matrix4();
   leavesMatrix.translate(-0.3, 0.75, -0.3);
   leavesMatrix.scale(0.6, 0.6, 0.6);
   leaves.matrix = leavesMatrix;
   leaves.renderfast();

   for (let i = 0; i < g_placedBlocks.length; i++) {
       g_placedBlocks[i].renderfast();
   }

   if (typeof g_enemies !== 'undefined') {
      for (let i = 0; i < g_enemies.length; i++) {
            g_enemies[i].renderfast();
      }
   }
}