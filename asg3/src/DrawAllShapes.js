var g_map=[
   // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
]

function drawMap(){
   // ... (your existing map/fence code remains unchanged) ...
   for (x = 0; x < 32; x++){
      for (y = 0; y < 32; y++){
         if ((x == 0 || x == 31) && y%4 == 0){
            var wall = new Cube();
            wall.color = [.80, .70, .40, 1.0];
            wall.textureNum = -2;
            wall.matrix.scale(0.25,0.25,0.25);
            wall.matrix.translate(x-16,-.25,y-16);
            wall.renderfast();
         }
         if ((x == 0 || x == 31) && y%4 != 0){
            var wall = new Cube();
            wall.color = [.60, .40, .20, 1.0];
            wall.textureNum = -2;
            wall.matrix.scale(0.25,0.73,0.25);
            wall.matrix.translate(x-16,-.25,y-16);
            wall.renderfast();
         }
         if ((y == 0 || y == 31) && x%4 == 0){
            var wall = new Cube();
            wall.color = [.80, .70, .50, 1.0];
            wall.textureNum = -2;
            wall.matrix.scale(0.25,0.25,0.25);
            wall.matrix.translate(x-16,-.25,y-16);
            wall.renderfast();
         }
         if ((y == 0 || y == 31) && x%4 != 0){
            var wall = new Cube();
            wall.color = [.60, .40, .20, 1.0];
            wall.textureNum = -2;
            wall.matrix.scale(0.25,0.73,0.25);
            wall.matrix.translate(x-16,-.25,y-16);
            wall.renderfast();
         }
      }
   }
}

function drawTreeFence() {
   const fencePostColor = [0.6, 0.4, 0.2, 1.0];    // Brownish color for posts
   const fenceRailColor = [0.65, 0.45, 0.25, 1.0]; // Slightly lighter for rails
   const groundLevel = -0.25;                      // Base Y level for objects on the floor

   // Define fence dimensions and properties
   const fenceRadius = 0.7; // Half-width of the fenced area (tree's widest part is ~0.3 radius)
   const postDimensions = { w: 0.1, h: 0.5, d: 0.1 }; // Width, Height, Depth of posts
   const railDimensions = { h: 0.08, d: 0.05 };       // Height, Depth of rails (length will vary)

   // Helper function to create and render a fence component (cube)
   function createFenceComponent(color, matrix) {
       let component = new Cube();
       component.color = color;
       component.textureNum = -2; // Solid color
       component.matrix = matrix;
       component.renderfast();
   }

   // --- Corner Posts ---
   // Positions for the center of each post
   const postPositions = [
       [-fenceRadius, groundLevel + postDimensions.h / 2, -fenceRadius], // Front-left
       [ fenceRadius, groundLevel + postDimensions.h / 2, -fenceRadius], // Front-right
       [-fenceRadius, groundLevel + postDimensions.h / 2,  fenceRadius], // Back-left
       [ fenceRadius, groundLevel + postDimensions.h / 2,  fenceRadius]  // Back-right
   ];

   for (let pos of postPositions) {
       let matrix = new Matrix4();
       matrix.translate(pos[0], pos[1], pos[2]); // Move to post's center position
       matrix.scale(postDimensions.w, postDimensions.h, postDimensions.d); // Scale to post's dimensions
       matrix.translate(-0.5, -0.5, -0.5); // Center the unit cube before scaling & world translation
       createFenceComponent(fencePostColor, matrix);
   }

   // --- Rails ---
   // Y positions for the center of the lower and upper rails
   const railYCoords = [
       groundLevel + 0.15 + railDimensions.h / 2, // Lower rail center Y
       groundLevel + 0.35 + railDimensions.h / 2  // Upper rail center Y
   ];
   const railLength = fenceRadius * 2; // The full length of a side of the fence

   // Front and Back Rails (run along X-axis)
   for (let z_coord of [-fenceRadius, fenceRadius]) { // z_coord is where the rail is placed (front or back)
       for (let y_coord of railYCoords) {
           let matrix = new Matrix4();
           matrix.translate(0, y_coord, z_coord); // Center of rail (X=0, specified Y and Z)
           matrix.scale(railLength, railDimensions.h, railDimensions.d); // Scale: X is length
           matrix.translate(-0.5, -0.5, -0.5);
           createFenceComponent(fenceRailColor, matrix);
       }
   }

   // Left and Right Rails (run along Z-axis)
   for (let x_coord of [-fenceRadius, fenceRadius]) { // x_coord is where the rail is placed (left or right)
       for (let y_coord of railYCoords) {
           let matrix = new Matrix4();
           matrix.translate(x_coord, y_coord, 0); // Center of rail (specified X and Y, Z=0)
           matrix.scale(railDimensions.d, railDimensions.h, railLength); // Scale: Z is length
           matrix.translate(-0.5, -0.5, -0.5);
           createFenceComponent(fenceRailColor, matrix);
       }
   }
}

function drawAllShapes(){
   drawTreeFence();

   // Sky
   var sky = new Cube();
   sky.color = [.6, .9, .95, 1];
   sky.textureNum = 1;
   sky.matrix.scale(10,10,10);
   sky.matrix.translate(-.5, -.5, -.5);
   sky.render();

   // Floor
   var floor = new Cube();
   floor.color = [.2, .9, .4, 1];
   floor.textureNum = 0;
   floor.matrix.translate(0,-.25,0);
   floor.matrix.scale(10,0,10);
   floor.matrix.translate(-.5, 0, -.5);
   floor.render();

   // Tree
   // Trunk
   var trunk = new Cube();
   trunk.color = [0.5, 0.35, 0.2, 1.0];
   trunk.textureNum = -2;
   var trunkMatrix = new Matrix4();
   trunkMatrix.translate(-0.1, -0.25, -0.1);
   trunkMatrix.scale(0.2, 1.0, 0.2);
   trunk.matrix = trunkMatrix;
   trunk.renderfast();
   // Leaves
   var leaves = new Cube();
   leaves.color = [0.2, 0.6, 0.1, 1.0];
   leaves.textureNum = -2;
   var leavesMatrix = new Matrix4();
   leavesMatrix.translate(-0.3, 0.75, -0.3);
   leavesMatrix.scale(0.6, 0.6, 0.6);
   leaves.matrix = leavesMatrix;
   leaves.renderfast();

   // Iterate through the g_placedBlocks array (defined in asg3.js)
   // and render each block.
   for (let i = 0; i < g_placedBlocks.length; i++) {
       // We stored Cube objects with their matrices already set up.
       // We'll use renderfast() as they are solid color.
       g_placedBlocks[i].renderfast();
   }
}